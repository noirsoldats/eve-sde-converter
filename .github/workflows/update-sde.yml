name: Update EVE SDE and Release DBs

on:
  schedule:
    # Run once per day at 12:00 UTC
    - cron: "0 12 * * *"
  workflow_dispatch:       # optional manual trigger

jobs:
  check-and-update-sde:
    runs-on: ubuntu-latest

    # Only run this job on main
    if: github.ref == 'refs/heads/main'

    outputs:
      update_needed: ${{ steps.compare.outputs.update_needed }}
      latest_build:  ${{ steps.get_latest_sde.outputs.latest_build }}
      version_tag:   ${{ steps.release_version.outputs.version_tag }}
      version_name:  ${{ steps.release_version.outputs.version_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Detect trigger type
        id: trigger_type
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Trigger: Manual (workflow_dispatch)"
            echo "is_manual=true" >> "$GITHUB_OUTPUT"
          else
            echo "Trigger: Automatic (schedule)"
            echo "is_manual=false" >> "$GITHUB_OUTPUT"
          fi
        shell: bash

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libyaml-dev

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # 1) Get previous build number from latest GitHub release
      - name: Get previous build from latest release
        id: get_previous_sde
        run: |
          # Get the latest release tag
          latest_tag=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "")

          if [ -n "$latest_tag" ]; then
            # Extract build number from tag (format: sde-{buildNumber} or sde-{buildNumber}.{patch})
            # Remove 'sde-' prefix
            version_part="${latest_tag#sde-}"
            # Extract base build number (remove .XX patch if present)
            previous_build="${version_part%%.*}"
          else
            previous_build=""
          fi

          echo "Latest release tag: '${latest_tag}'"
          echo "Previous SDE build number: '${previous_build}'"
          echo "previous_build=${previous_build}" >> "$GITHUB_OUTPUT"
          echo "previous_tag=${latest_tag}" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash

      # 2) Fetch latest SDE build from CCP
      - name: Get latest SDE build number from CCP
        id: get_latest_sde
        run: |
          BASE="https://developers.eveonline.com/static-data"
          curl -s "$BASE/tranquility/latest.jsonl" > latest.jsonl

          python3 << 'PYCODE'
          import os, json

          latest_build = None
          with open("latest.jsonl", "r", encoding="utf-8") as f:
              for line in f:
                  line = line.strip()
                  if not line:
                      continue
                  rec = json.loads(line)
                  if rec.get("_key") == "sde":
                      latest_build = str(rec["buildNumber"])
                      break

          if not latest_build:
              raise SystemExit("Could not find SDE buildNumber in latest.jsonl")

          print(f"Latest SDE build number: {latest_build}")
          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as out:
              out.write(f"latest_build={latest_build}\n")
          PYCODE
        shell: bash

      # 3) Get all release tags (for manual patch calculation)
      - name: Get all release tags
        id: get_all_tags
        if: steps.trigger_type.outputs.is_manual == 'true'
        run: |
          tags=$(gh release list --limit 100 --json tagName --jq '.[].tagName' 2>/dev/null || echo "")
          echo "tags<<EOF" >> "$GITHUB_OUTPUT"
          echo "$tags" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash

      # 4) Calculate patch number for manual rebuild
      - name: Calculate patch number for manual rebuild
        id: calculate_patch
        if: steps.trigger_type.outputs.is_manual == 'true'
        run: |
          BUILD="${{ steps.get_latest_sde.outputs.latest_build }}"

          python3 << 'PYCODE'
          import os, re

          build_number = os.environ.get("BUILD", "")
          all_tags = os.environ.get("ALL_TAGS", "").strip().split("\n")

          # Pattern: sde-{BUILD}.{PATCH}
          pattern = rf"^sde-{re.escape(build_number)}\.(\d+)$"

          highest_patch = 0
          for tag in all_tags:
            tag = tag.strip()
            if not tag:
              continue
            match = re.match(pattern, tag)
            if match:
              patch_num = int(match.group(1))
              if patch_num > highest_patch:
                highest_patch = patch_num

          # Increment to get next patch number
          next_patch = highest_patch + 1

          # Format as zero-padded 2-digit number
          patch_str = f"{next_patch:02d}"

          print(f"Highest existing patch for build {build_number}: {highest_patch}")
          print(f"Next patch number: {patch_str}")

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as out:
            out.write(f"patch_number={patch_str}\n")
          PYCODE
        env:
          BUILD: ${{ steps.get_latest_sde.outputs.latest_build }}
          ALL_TAGS: ${{ steps.get_all_tags.outputs.tags }}
        shell: bash

      # 5) Compare previous vs latest
      - name: Decide whether to update
        id: compare
        run: |
          latest="${{ steps.get_latest_sde.outputs.latest_build }}"
          previous="${{ steps.get_previous_sde.outputs.previous_build }}"
          is_manual="${{ steps.trigger_type.outputs.is_manual }}"

          echo "Latest:   $latest"
          echo "Previous: $previous"
          echo "Trigger:  $([ "$is_manual" = "true" ] && echo "Manual" || echo "Automatic")"

          if [ "$is_manual" = "true" ]; then
            # Manual trigger: ALWAYS rebuild, regardless of build number
            echo "Manual trigger: Update required for patch release."
            echo "update_needed=true" >> "$GITHUB_OUTPUT"
          else
            # Automatic trigger: Only if build number changed
            if [ "$latest" != "$previous" ] && [ -n "$latest" ]; then
              echo "SDE build changed; update needed."
              echo "update_needed=true" >> "$GITHUB_OUTPUT"
            else
              echo "No build change; no update needed."
              echo "update_needed=false" >> "$GITHUB_OUTPUT"
            fi
          fi
        shell: bash

      # 4) Download and extract SDE if update needed
      - name: Download SDE from CCP
        if: steps.compare.outputs.update_needed == 'true'
        run: |
          BUILD="${{ steps.get_latest_sde.outputs.latest_build }}"
          SDE_URL="https://developers.eveonline.com/static-data/tranquility/eve-online-static-data-${BUILD}-yaml.zip"
          echo "Downloading SDE from: $SDE_URL"
          curl -L -o sde.zip "$SDE_URL"

          echo "Extracting SDE..."
          # Remove existing sde directory if it exists (for local act testing)
          rm -rf sde
          unzip -q sde.zip -d sde

          echo "SDE ready at: sde/"
          ls -la sde/

      # 5) Run Load.py to generate eve.db & eve-stripped.db
      - name: Run Load.py for new SDE
        if: steps.compare.outputs.update_needed == 'true'
        run: |
          echo "Running Load.py for latest SDE..."
          python3 Load.py sqlite en --create-stripped

      # 6) Determine release version
      - name: Determine release version
        id: release_version
        if: steps.compare.outputs.update_needed == 'true'
        run: |
          BUILD="${{ steps.get_latest_sde.outputs.latest_build }}"
          IS_MANUAL="${{ steps.trigger_type.outputs.is_manual }}"

          if [ "$IS_MANUAL" = "true" ]; then
            PATCH="${{ steps.calculate_patch.outputs.patch_number }}"
            VERSION_TAG="sde-${BUILD}.${PATCH}"
            VERSION_NAME="SDE ${BUILD}.${PATCH} SQLite (Patch Release)"
          else
            VERSION_TAG="sde-${BUILD}"
            VERSION_NAME="SDE ${BUILD} SQLite"
          fi

          echo "Release tag:  $VERSION_TAG"
          echo "Release name: $VERSION_NAME"

          echo "version_tag=${VERSION_TAG}" >> "$GITHUB_OUTPUT"
          echo "version_name=${VERSION_NAME}" >> "$GITHUB_OUTPUT"
        shell: bash

      # 7) Upload DBs as artifact for the release job
      - name: Upload DB artifacts
        if: steps.compare.outputs.update_needed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: sde-databases
          path: |
            eve.db
            eve-stripped.db
          retention-days: 7

  create-release:
    runs-on: ubuntu-latest
    needs: check-and-update-sde

    # Only create a release if an update is needed AND we're on main
    if: needs.check-and-update-sde.outputs.update_needed == 'true' && github.ref == 'refs/heads/main'

    steps:
      - name: Download DB artifact
        uses: actions/download-artifact@v4
        with:
          name: sde-databases
          path: .

      # Now eve.db and eve-stripped.db are present

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.check-and-update-sde.outputs.version_tag }}
          name: ${{ needs.check-and-update-sde.outputs.version_name }}
          draft: false
          prerelease: false
          body: |
            EVE Online Static Data Export databases (SQLite format).

            **Build Number:** ${{ needs.check-and-update-sde.outputs.latest_build }}
            **Trigger:** ${{ github.event_name == 'workflow_dispatch' && 'Manual' || 'Automatic' }}

            Contains:
            - `eve.db` - Full database with all SDE data
            - `eve-stripped.db` - Stripped database with essential tables only
          files: |
            eve.db
            eve-stripped.db
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
